
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>leetcode.impl.solution &#8212; leetcode 1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../../index.html">
          <span>leetcode 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>leetcode.impl.solution</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for leetcode.impl.solution</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Use the Solution class to represent Leedcode problems</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;docstring for insert&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">PrintListNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">PrintListNode</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
<span class="c1">#         print(self.val)</span>


<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;docstring for insert&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">PrintTree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">PrintTree</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">PrintTree</span><span class="p">()</span>


<div class="viewcode-block" id="Solution"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution">[docs]</a><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~leetcode.impl.solution` object is the leetcode quiz module</span>

<span class="sd">    This module is to implementate the leetcode problems</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Solution.twoSum"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.twoSum">[docs]</a>    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 1. Two Sum (Easy)</span>

<span class="sd">        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</span>
<span class="sd">        You may assume that each input would have exactly one solution, and you may not use the same element twice.</span>
<span class="sd">        You can return the answer in any order.</span>

<span class="sd">        :param num:  array of integers</span>
<span class="sd">        :type  num:  List[int]</span>
<span class="sd">        :param target:  integer target</span>
<span class="sd">        :type  target:  inEasyt</span>

<span class="sd">        :return:  indices of the two numbers such that they add up to target</span>
<span class="sd">        :rtype:   List[int]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">store</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rest</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">store</span><span class="p">:</span>
                <span class="n">store</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">store</span><span class="p">[</span><span class="n">rest</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="Solution.minNumberOfSemesters"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minNumberOfSemesters">[docs]</a>    <span class="k">def</span> <span class="nf">minNumberOfSemesters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dependencies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 1496. Parallel Courses II (HARD)</span>

<span class="sd">        You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where</span>
<span class="sd">        relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei:</span>
<span class="sd">        course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.</span>

<span class="sd">        In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters</span>
<span class="sd">        for the courses you are taking.</span>

<span class="sd">        Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is </span>
<span class="sd">        possible to take every course.</span>

<span class="sd">        :param n:  courses</span>
<span class="sd">        :type n:  int</span>

<span class="sd">        :param dependencies: prerequisite relationship between course prevCoursei and course nextCoursei has to be taken before course nextCoursi</span>
<span class="sd">        :type dependencies:  List[List[int]]</span>

<span class="sd">        :param k:  take at most k courses</span>
<span class="sd">        :type  k:  int</span>

<span class="sd">        :return:  minimum number of semesters needed to take all courses</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute in-degree and adjacency graph for each node</span>
        <span class="n">in_degree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prerequisite</span><span class="p">,</span> <span class="n">course</span> <span class="ow">in</span> <span class="n">dependencies</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">prerequisite</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">course</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">course</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">find_min_semester</span><span class="p">(</span><span class="n">courses</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">courses</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="n">combinations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">courses</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

            <span class="n">min_semester</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span>
            <span class="k">for</span> <span class="n">k_courses</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
                <span class="n">remaining_courses</span> <span class="o">=</span> <span class="n">courses</span> <span class="o">-</span> <span class="n">k_courses</span>

                <span class="n">next_courses</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Decrease the in-degree</span>
                <span class="k">for</span> <span class="n">course_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">course_idx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">k_courses</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">course_idx</span><span class="p">]:</span>
                            <span class="n">in_degree</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">next_courses</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">nei</span>

                <span class="n">min_semester</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_semester</span><span class="p">,</span> <span class="n">find_min_semester</span><span class="p">(</span><span class="n">remaining_courses</span> <span class="o">+</span> <span class="n">next_courses</span><span class="p">))</span>

                <span class="c1"># Increase the in-degree (backtracking)</span>
                <span class="k">for</span> <span class="n">course_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">course_idx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">k_courses</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">course_idx</span><span class="p">]:</span>
                            <span class="n">in_degree</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">min_semester</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">initial_courses</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">initial_courses</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>

        <span class="k">return</span> <span class="n">find_min_semester</span><span class="p">(</span><span class="n">initial_courses</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">count1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">number</span>
        <span class="k">while</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ones</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">tmp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ones</span>

    <span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>

        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">current_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_ones</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">remain_1s</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">remain_1s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num_ones</span> <span class="o">&lt;=</span> <span class="n">remain_1s</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">current_number</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># `(current_number - 1) ^ current_number` will give us all 1s starting from the smallest `1`</span>
                <span class="n">last_one</span> <span class="o">=</span> <span class="p">((</span><span class="n">current_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">current_number</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">current_number</span>

                <span class="c1"># For choosing the last `1`</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">current_number</span> <span class="o">-</span> <span class="n">last_one</span><span class="p">,</span> <span class="n">num_ones</span><span class="o">=</span><span class="n">num_ones</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">remain_1s</span><span class="o">=</span><span class="n">remain_1s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># For not choosing the last `1`</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">current_number</span> <span class="o">-</span> <span class="n">last_one</span><span class="p">,</span> <span class="n">num_ones</span><span class="o">=</span><span class="n">num_ones</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">remain_1s</span><span class="o">=</span><span class="n">remain_1s</span><span class="p">)</span>

                <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">last_one</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p2</span>

        <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">current_number</span><span class="o">=</span><span class="n">number</span><span class="p">,</span> <span class="n">num_ones</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">count1</span><span class="p">(</span><span class="n">number</span><span class="p">),</span> <span class="n">remain_1s</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

<div class="viewcode-block" id="Solution.convertToTitle"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.convertToTitle">[docs]</a>    <span class="k">def</span> <span class="nf">convertToTitle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnNumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 168. Excel Sheet Column Title (Medium)</span>

<span class="sd">        Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.</span>

<span class="sd">        :param columnNumber:  Execel sheet</span>
<span class="sd">        :type  columnNumber:  int</span>

<span class="sd">        :return:  its corresponding column title</span>
<span class="sd">        :rtype:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">while</span> <span class="n">columnNumber</span><span class="p">:</span>
            <span class="n">columnNumber</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">65</span> <span class="o">+</span> <span class="n">columnNumber</span> <span class="o">%</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="n">ans</span>
            <span class="n">columnNumber</span> <span class="o">//=</span> <span class="mi">26</span>
        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.isMatch"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isMatch">[docs]</a>    <span class="k">def</span> <span class="nf">isMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 10. Regular Expression Matching (HARD)</span>

<span class="sd">        Given an input string s and a pattern p, implement regular expression matching with support for &#39;.&#39; and &#39;*&#39; where:</span>

<span class="sd">        &#39;.&#39; Matches any single character.</span>
<span class="sd">        &#39;*&#39; Matches zero or more of the preceding element.</span>
<span class="sd">        The matching should cover the entire input string (not partial).</span>

<span class="sd">        :param s: input string</span>
<span class="sd">        :type  s: string</span>

<span class="sd">        :param p: pattern character</span>
<span class="sd">        :type  p: string</span>

<span class="sd">        :return:  whehter the matching pattern cover the entire input string</span>
<span class="sd">        :rtype:  bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">len_s</span><span class="p">,</span> <span class="n">len_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># [len(p) + 1 x len(s) + 1] possible value of state, if match, then True</span>
        <span class="c1"># [pattern][text]</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">len_p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_s</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># text</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_p</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># pattern</span>

                <span class="c1"># finding a rule and determine the police function</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                    <span class="c1"># check the pattern repeats for 0 time or the pattern repeats for at least 1 time</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># check the pattern is the same</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>

        <span class="c1"># best possible</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">len_s</span><span class="p">][</span><span class="n">len_p</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        len_s, len_p = len(s), len(p)</span>

<span class="sd">        # possible value of state, if match, then True</span>
<span class="sd">        # [text][pattern]</span>
<span class="sd">        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]</span>

<span class="sd">        dp[0][0] = True</span>

<span class="sd">        for i in range(1, len_p+1):</span>
<span class="sd">            if p[i-1] == &#39;*&#39;:</span>
<span class="sd">                dp[0][i] = dp[0][i-2]</span>

<span class="sd">        for i in range(1, len_s + 1):</span>
<span class="sd">            for j in range(1, len_p + 1):</span>

<span class="sd">                # &#39;*&#39; Matches zero or more of the preceding element.</span>
<span class="sd">                if p[j-1] == &#39;*&#39;:</span>
<span class="sd">                    if (p[j-2] == s[i-1] or p[j-2] == &#39;.&#39;):</span>
<span class="sd">                        dp[i][j] = dp[i-1][j]</span>
<span class="sd">                    else:</span>
<span class="sd">                        dp[i][j] = dp[i][j-2]</span>

<span class="sd">                elif (p[j-1] == s[i-1] or p[j-1] == &#39;.&#39;):</span>
<span class="sd">                    dp[i][j] = dp[i-1][j-1]</span>

<span class="sd">        return dp[-1][-1]</span>

<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="Solution.romanToInt"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.romanToInt">[docs]</a>    <span class="k">def</span> <span class="nf">romanToInt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 13. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. (Easy)</span>

<span class="sd">        Symbol       Value</span>
<span class="sd">        I             1</span>
<span class="sd">        V             5</span>
<span class="sd">        X             10</span>
<span class="sd">        L             50</span>
<span class="sd">        C             100</span>
<span class="sd">        D             500</span>
<span class="sd">        M             1000</span>

<span class="sd">        For example, 2 is written as II in Roman numeral, just two one&#39;s added together. 12 is written as XII, which is simple X + II. The number 27 is written as XXVII, which is XX + V + II.</span>

<span class="sd">        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not III. Instead, the number four is written as IV. Because the one is before the five we substract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where substraction used:</span>
<span class="sd">        </span>
<span class="sd">        - I can be placed before V (5) and X (10) to make 4 and 9.</span>
<span class="sd">        - X can be placed before L (50) and C (100) to make 40 and 90</span>
<span class="sd">        - C can be placed before D (500) and M (1000) to make 400 and 900</span>

<span class="sd">        Given a roman numeral, convert it to an integer.</span>

<span class="sd">        :param s:  Roman numeral</span>
<span class="sd">        :type  s:  string</span>

<span class="sd">        :return:  integer</span>
<span class="sd">        :rtype:   int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">}</span>

        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">len_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_num</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">total</span> <span class="o">-=</span> <span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="c1"># The last string</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">total</span></div>

<div class="viewcode-block" id="Solution.maxLength"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.maxLength">[docs]</a>    <span class="k">def</span> <span class="nf">maxLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 1239. Maximum Length of a Concatencated String with Unique Characters (Medium)</span>

<span class="sd">        You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters that has unique characters.</span>

<span class="sd">        A subsequence is an array that can be derived from another array of by deleting some or no elements without changing the order of the remaining elements.</span>

<span class="sd">        :param arr:  array of strings</span>
<span class="sd">        :type  arr:  List[str]</span>

<span class="sd">        :return:  the maximum possible length of subsequence</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        def dfs_maxlength(arr, cur, visited, idx):</span>
<span class="sd">            if idx == len(arr):</span>
<span class="sd">                return</span>

<span class="sd">            for i in range(idx, len(arr)):</span>
<span class="sd">                # repetition</span>
<span class="sd">                if i in visited:</span>
<span class="sd">                    continue</span>

<span class="sd">                # not unique</span>
<span class="sd">                if len(cur) + len(arr[i]) != len(set(cur + arr[i])):</span>
<span class="sd">                    continue</span>

<span class="sd">                self.maxlen = max(self.maxlen, len(cur) + len(arr[i]))</span>

<span class="sd">                visited.add(i)</span>
<span class="sd">                dfs_maxlength(arr, cur + arr[i], visited, i + 1)</span>
<span class="sd">                visited.remove(i) # backtracking</span>

<span class="sd">        self.maxlen = 0</span>

<span class="sd">        dfs_maxlength(arr, &#39;&#39;, set(), 0)</span>

<span class="sd">        return self.maxlen</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">ans</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">dfs_length</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">temp</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ans</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="k">continue</span>

                <span class="n">dfs_length</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">temp</span><span class="o">+</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">dfs_length</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.criticalConnections"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.criticalConnections">[docs]</a>    <span class="k">def</span> <span class="nf">criticalConnections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">connections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 1192. Critical Connections in a Network (HARD)</span>

<span class="sd">        There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.</span>

<span class="sd">        A critical connection is a connection that, if removed, will make some servers unable to reach some other server.</span>

<span class="sd">        Return all critical connections in the network in any order.</span>

<span class="sd">        :param connections:  Undirected server-to-server connections forming a network</span>
<span class="sd">        :type  connections:  List[List[int]]</span>

<span class="sd">        :return:  all critical connections in the network in any order</span>
<span class="sd">        :rtype:  List[List[int]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="sd">&#39;&#39;&#39; Time Limit Exceeded &#39;&#39;&#39;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        critConns = []</span>

<span class="sd">        def buildGraph(exclude, conns):</span>
<span class="sd">            graph = defaultdict(list)</span>
<span class="sd">            for conn in conns:</span>
<span class="sd">                # critical connection (bridge)</span>
<span class="sd">                if conn == exclude:</span>
<span class="sd">                    continue</span>
<span class="sd">                graph[conn[0]].append(conn[1])</span>
<span class="sd">                graph[conn[1]].append(conn[0])</span>
<span class="sd">            return graph</span>

<span class="sd">        def dfs_traversal(graph, visited, curNode):</span>
<span class="sd">            visited.add(curNode)</span>
<span class="sd">            for neighbor in graph[curNode]:</span>
<span class="sd">                if neighbor in visited:</span>
<span class="sd">                    continue</span>
<span class="sd">                dfs_traversal(graph, visited, neighbor)</span>

<span class="sd">        for conn in connections:</span>
<span class="sd">            # build graph</span>
<span class="sd">            graph = buildGraph(conn, connections)</span>
<span class="sd">            visited = set()</span>

<span class="sd">            dfs_traversal(graph, visited, 0)</span>

<span class="sd">            # low link value</span>
<span class="sd">            print(len(visited))</span>
<span class="sd">            if n != len(visited):</span>
<span class="sd">                critConns.append(conn)</span>

<span class="sd">        return critConns</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build undirected graph</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sor</span><span class="p">,</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">sor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sor</span><span class="p">)</span>

        <span class="n">low_link</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">dfs_visit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">from_node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">low_link</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

            <span class="n">cur_id</span> <span class="o">=</span> <span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">low_link</span><span class="p">)</span>

            <span class="c1"># Traversal</span>
            <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>

                <span class="k">if</span> <span class="n">neigh</span> <span class="o">==</span> <span class="n">from_node</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Track the smallest low link value</span>
                <span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">dfs_visit</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>

            <span class="c1"># Determine critical connection (bridge)</span>
            <span class="c1"># according to when the low link value is equal to visited time.</span>
            <span class="k">if</span> <span class="n">cur_id</span> <span class="o">==</span> <span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="ow">and</span> <span class="n">from_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">from_node</span><span class="p">,</span> <span class="n">node</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="n">dfs_visit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Solution.arrayNesting"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.arrayNesting">[docs]</a>    <span class="k">def</span> <span class="nf">arrayNesting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 565. Array Nesting (Medium)</span>
<span class="sd">        You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].</span>

<span class="sd">        You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:</span>

<span class="sd">        The first element in s[k] starts with the selection of the element nums[k] of index = k.</span>
<span class="sd">        The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.</span>
<span class="sd">        We stop adding right before a duplicate element occurs in s[k].</span>

<span class="sd">        Return the longest length of a set s[k].</span>

<span class="sd">        :param nums:  integer array nums of length n</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the longest length of a set s[k]</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.findPeakElement"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.findPeakElement">[docs]</a>    <span class="k">def</span> <span class="nf">findPeakElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 162. Find Peak Element (Medium)</span>

<span class="sd">        A peak element is an element that is strictly greater than its neighbors.</span>

<span class="sd">        Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.</span>

<span class="sd">        You may imagine that nums[-1] = nums[n] = -∞.</span>

<span class="sd">        You must write an algorithm that runs in O(log n) time.</span>

<span class="sd">        :param nums:  integer array</span>
<span class="sd">        :type  nums:  int</span>

<span class="sd">        :return:  peak element</span>
<span class="sd">        :rtype:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">start</span></div>

<div class="viewcode-block" id="Solution.judgeCircle"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.judgeCircle">[docs]</a>    <span class="k">def</span> <span class="nf">judgeCircle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moves</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 657. Robot Return to Origin (Easy)</span>

<span class="sd">        There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.</span>

<span class="sd">        You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are &#39;R&#39; (right), &#39;L&#39; (left), &#39;U&#39; (up), and &#39;D&#39; (down).</span>

<span class="sd">        Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.</span>

<span class="sd">        Note: The way that the robot is &quot;facing&quot; is irrelevant. &#39;R&#39; will always make the robot move to the right once, &#39;L&#39; will always make it move left, etc. Also, assume that the magnitude of the robot&#39;s movement is the same for each move.</span>

<span class="sd">        :param moves:  the represents the move sequence of the robot </span>
<span class="sd">        :type  moves:  str</span>

<span class="sd">        :return:  whether or not the robot returns to the origin after it finishes all of its moves</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">moves</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Solution.longestStrChain"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.longestStrChain">[docs]</a>    <span class="k">def</span> <span class="nf">longestStrChain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 1048. Longest String Chain (Medium)</span>

<span class="sd">        You are given an array of words where each word consists of lowercase English letters.</span>

<span class="sd">        wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make </span>
<span class="sd">        it equal to wordB.</span>

<span class="sd">        For example, &quot;abc&quot; is a predecessor of &quot;abac&quot;, while &quot;cba&quot; is not a </span>
<span class="sd">        predecessor of &quot;bcad&quot;.</span>

<span class="sd">        A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, </span>
<span class="sd">        and so on. A single word is trivially a word chain with k == 1.</span>

<span class="sd">        Return the length of the longest possible word chain with words chosen from the given list of words.</span>

<span class="sd">        :param words:  an array of words where each word consists of lowercase English letters.</span>
<span class="sd">        :type  words:  List[str]</span>

<span class="sd">        :return:  the length of the longest possible word chain with words choosen from the given list of words</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="c1"># sorted array of words</span>
        <span class="n">words</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">elem</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>

        <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">word</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
                <span class="n">newWord</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

                <span class="k">if</span> <span class="n">newWord</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">:</span>
                    <span class="n">ref</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="n">ref</span><span class="p">[</span><span class="n">newWord</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">lengthwordchain</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">elem</span><span class="p">:</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">lengthwordchain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Solution.lengthOfLongestSubstring"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.lengthOfLongestSubstring">[docs]</a>    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 3. Longest Substring Without Repeating Characters (Medium)</span>

<span class="sd">        Given a string s, find the length of the longest substring without repeating characters.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  the length of the longest substring without repeating characters</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">subStr</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">currentCount</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Substring</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">subStr</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="n">subStr</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">currentCount</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">maxCount</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxCount</span><span class="p">,</span> <span class="n">currentCount</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">maxCount</span></div>

<div class="viewcode-block" id="Solution.minimumCardPickup"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minimumCardPickup">[docs]</a>    <span class="k">def</span> <span class="nf">minimumCardPickup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cards</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 2260. Minimum Consecutive Cards to Pick Up</span>

<span class="sd">        You are give an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value.</span>

<span class="sd">        Return the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.</span>

<span class="sd">        :param cards:  integer array cards</span>
<span class="sd">        :type  cards:  List[int]</span>

<span class="sd">        :return:  the minimum number of consecutive cards</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matchedcard</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># Pair of matching cards among picked cards</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cards</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">matchedcard</span><span class="p">:</span>
                <span class="c1"># number of consecutive cards</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">matchedcard</span><span class="p">[</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>

            <span class="n">matchedcard</span><span class="p">[</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="n">ans</span> <span class="k">if</span> <span class="n">ans</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Solution.findCircleNum"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.findCircleNum">[docs]</a>    <span class="k">def</span> <span class="nf">findCircleNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isConnected</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 547. Number of Provinces (Medium)</span>

<span class="sd">        There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is </span>
<span class="sd">        connected directly with city c, then city a is connected indirectly with city c.</span>

<span class="sd">        A province is a group of directly or indirectly connected cities and no other cities outside of the group.</span>

<span class="sd">        You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, </span>
<span class="sd">        and isConnected[i][j] = 0 otherwise.</span>

<span class="sd">        Return the total number of provinces.</span>

<span class="sd">        :param isConnected:  a province is a group of directly or indirectly connected cities and no other cities outside of the group</span>
<span class="sd">        :type  isConnected:  List[List[int]]</span>

<span class="sd">        :return:  the total number of provinces</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isConnected</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs_connected</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">isConnected</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
                <span class="c1"># a group of directly connected cities</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">dfs_connected</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">dfs_connected</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="Solution.canFinish"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.canFinish">[docs]</a>    <span class="k">def</span> <span class="nf">canFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 207. Course Schedule (Medium)</span>

<span class="sd">        There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites </span>
<span class="sd">        where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.</span>

<span class="sd">        For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.</span>

<span class="sd">        Return true if you can finish all courses. Otherwise, return false.</span>

<span class="sd">        :param numCourses:  total of number courses you have to take</span>
<span class="sd">        :type  numCourses:  int</span>

<span class="sd">        :param prerequisites:  array prerequisites</span>
<span class="sd">        :type  prerequisites:  List[List[int]]</span>

<span class="sd">        :return:  whether or not you can finish all courses.</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">marks</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># create graph</span>
        <span class="k">for</span> <span class="n">course</span><span class="p">,</span> <span class="n">prereq</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">prereq</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">course</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dfs_course</span><span class="p">(</span><span class="n">course</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">marks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

            <span class="n">marks</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">course</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">marks</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dfs_course</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">marks</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">marks</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># finish the prerequisites and course</span>
            <span class="n">marks</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">course</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">marks</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dfs_course</span><span class="p">(</span><span class="n">course</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">marks</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Solution.lengthOfLIS"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.lengthOfLIS">[docs]</a>    <span class="k">def</span> <span class="nf">lengthOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 300. Longest Increasing Subsequence (Medium)</span>

<span class="sd">        Given an integer array nums, return the length of the longest strictly increasing subsequence.</span>

<span class="sd">        A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing</span>
<span class="sd">        the order of the remaining elements. For example, [0, 3, 6, 7] is a subsequence of the array [0,3,1,6,2,2,7].</span>

<span class="sd">        :param nums:  array nums</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the longest strictly increasing subsequence</span>
<span class="sd">        :rtype:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="c1"># possible value of state</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

        <span class="c1"># for each subsequence ending at index i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>

            <span class="c1"># find the rule and police function</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.originalDigits"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.originalDigits">[docs]</a>    <span class="k">def</span> <span class="nf">originalDigits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 423. Reconstruct Original Digits from English (Medium)</span>

<span class="sd">        Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.</span>

<span class="sd">        :param s:  string containing an out-of-order English</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  the digits in ascending order</span>
<span class="sd">        :rtype:  str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>

        <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>

        <span class="n">c</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>

        <span class="n">c</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.strongPasswordChecker"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.strongPasswordChecker">[docs]</a>    <span class="k">def</span> <span class="nf">strongPasswordChecker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">password</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Strong Password Checker (HARD)</span>

<span class="sd">        A password is considered strong if the below conditions are all met:</span>

<span class="sd">        It has at least 6 characters and at most 20 characters.</span>
<span class="sd">        It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.</span>
<span class="sd">        It does not contain three repeating characters in a row (i.e., &quot;...aaa...&quot; is weak, but &quot;...aa...a...&quot; is strong, assuming other conditions are met).</span>
<span class="sd">        Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.</span>

<span class="sd">        In one step, you can:</span>

<span class="sd">        Insert one character to password,</span>
<span class="sd">        Delete one character from password, or</span>
<span class="sd">        Replace one character of password with another character.</span>


<span class="sd">        :param password:  password</span>
<span class="sd">        :type  password:  str</span>

<span class="sd">        :return:  the minimum number of steps required to make password strong</span>
<span class="sd">        :rtype:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>

        <span class="c1"># character check (replace)</span>
        <span class="n">containsUpper</span><span class="p">,</span> <span class="n">containsLower</span><span class="p">,</span> <span class="n">containsDigit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">password</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">containsUpper</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
                <span class="n">containsUpper</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">containsLower</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">islower</span><span class="p">():</span>
                <span class="n">containsLower</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">containsDigit</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">containsDigit</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">c_swaps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="p">(</span><span class="n">containsUpper</span> <span class="o">+</span> <span class="n">containsLower</span> <span class="o">+</span> <span class="n">containsDigit</span><span class="p">))</span>

        <span class="c1"># repeating check (replace)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">password</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">password</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">reps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1"># length (addition, subtraction)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">adds</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">-</span> <span class="n">n</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">adds</span><span class="p">,</span> <span class="n">c_swaps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
            <span class="n">r_swaps</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">elem</span> <span class="o">//</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">reps</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c_swaps</span><span class="p">,</span> <span class="n">r_swaps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">20</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">subs</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">subs</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">subs</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>
                    <span class="n">subs</span> <span class="o">-=</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">subs</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">removed</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">removed</span>
                    <span class="n">subs</span> <span class="o">-=</span> <span class="n">removed</span>

            <span class="n">r_swaps</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">elem</span> <span class="o">//</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">reps</span><span class="p">])</span>

            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c_swaps</span><span class="p">,</span> <span class="n">r_swaps</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.maxProfitIV"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.maxProfitIV">[docs]</a>    <span class="k">def</span> <span class="nf">maxProfitIV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 188. Best Time to Buy and Sell Stock IV (HARD)</span>

<span class="sd">        You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.</span>

<span class="sd">        Find the maximum profit you can achieve. You may complete at most k transactions.</span>

<span class="sd">        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</span>

<span class="sd">        :param prices:  the price of a given stock</span>
<span class="sd">        :type  prices:  List[int]</span>

<span class="sd">        :return:  the maximum profit you can achieve</span>
<span class="sd">        :rtype:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">trans_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">cur_balance_with_buy</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">day_d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">trans_k</span><span class="p">][</span><span class="n">day_d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">trans_k</span><span class="p">][</span><span class="n">day_d</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cur_balance_with_buy</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">day_d</span><span class="p">])</span>

                <span class="n">cur_balance_with_buy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cur_balance_with_buy</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">trans_k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">day_d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">day_d</span><span class="p">]</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Solution.minPathSum"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minPathSum">[docs]</a>    <span class="k">def</span> <span class="nf">minPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 64. Minimum Path Sum (Medium)</span>

<span class="sd">        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes </span>
<span class="sd">        the sum of all numbers along its path.</span>


<span class="sd">        Note: You can only move either down or right at any point in time.</span>

<span class="sd">        :param grid:  m x n grid filled with non-negative numbers</span>
<span class="sd">        :type  grid:  List[List[int]]</span>

<span class="sd">        :return:  minimizes the sum of all numbers along its path</span>
<span class="sd">        :rtype:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pathsum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dfs_path</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">col</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>

            <span class="c1"># Connected point</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pathsum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pathsum</span><span class="p">[(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)]</span>

            <span class="c1"># Up or Left</span>
            <span class="n">pathsum</span><span class="p">[(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dfs_path</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">),</span> <span class="n">dfs_path</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">pathsum</span><span class="p">[(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)]</span>

        <span class="c1"># begin from bottom right</span>
        <span class="k">return</span> <span class="n">dfs_path</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.searchRange"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.searchRange">[docs]</a>    <span class="k">def</span> <span class="nf">searchRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 34. Find First and Last Position of Element in Sorted Array (Medium)</span>

<span class="sd">        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</span>

<span class="sd">        If target is not found in the array, return [-1, -1].</span>

<span class="sd">        You must write an algorithm with O(log n) runtime complexity.</span>

<span class="sd">        :param nums:  array of integers</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the starting and ending position of a given target value</span>
<span class="sd">        :rtype:  List[int]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># reverse nums</span>
        <span class="n">reverse</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># first position</span>
            <span class="n">elem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
            <span class="c1"># last position</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">elem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">elem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">elem</span></div>

<div class="viewcode-block" id="Solution.maxSubArray"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.maxSubArray">[docs]</a>    <span class="k">def</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 53. Maximum Subarray docstring for maxSubArray (Easy)&quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</span>

<span class="sd">        A subarray is a contiguous part of an array.</span>

<span class="sd">        :param nums:  integer array</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the contiguous subarray</span>
<span class="sd">        :rtype:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">curr_max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">curr_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">curr_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">curr_sum</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span>
            <span class="n">curr_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">curr_sum</span><span class="p">,</span> <span class="n">curr_max</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">curr_max</span></div>

<div class="viewcode-block" id="Solution.simplifyPath"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.simplifyPath">[docs]</a>    <span class="k">def</span> <span class="nf">simplifyPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 71. Simplify Path (Medium)</span>

<span class="sd">        Given a string path, which is an absolute path (starting with a slash &#39;/&#39;) to a file or directory in a Unix-style file system,</span>
<span class="sd">        convert it to the simplified canonical path.</span>

<span class="sd">        In a Unix-style file system, a period &#39;.&#39; refers to the current directory, a double period &#39;..&#39; refers to the directory up a level,</span>
<span class="sd">        and any multiple consecutive slashes (i.e. &#39;//&#39;) are treated as a single slash &#39;/&#39;. For this problem, any other format of periods such </span>
<span class="sd">        as &#39;...&#39; are treated as file/directory names.</span>

<span class="sd">        The canonical path should have the following format:</span>

<span class="sd">        The path starts with a single slash &#39;/&#39;.</span>
<span class="sd">        Any two directories are separated by a single slash &#39;/&#39;.</span>
<span class="sd">        The path does not end with a trailing &#39;/&#39;.</span>
<span class="sd">        The path only contains the directories on the path from the root directory to the target file or directory </span>
<span class="sd">        (i.e., no period &#39;.&#39; or double period &#39;..&#39;)</span>

<span class="sd">        Return the simplified canonical path.</span>

<span class="sd">        :param path:  an absolute path to a file or directory in a Uinx-style file system</span>
<span class="sd">        :type  path:  str</span>

<span class="sd">        :return:  canonical path</span>
<span class="sd">        :rtype:  str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;..&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.subsets"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.subsets">[docs]</a>    <span class="k">def</span> <span class="nf">subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 78. Subsets (Medium)</span>

<span class="sd">        Given an integer array nums of unique elements, return all possible subsets (the power set).</span>

<span class="sd">        The solution set must not contain duplicate subsets. Return the solution in any order.</span>

<span class="sd">        :param param:  integer array nums of unique elements</span>
<span class="sd">        :type  param:  List[int]</span>

<span class="sd">        :return:  all possible subsets (the power set)</span>
<span class="sd">        :rtype:  List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        subset = []</span>

<span class="sd">        def recurse(start_index, current_subset):</span>

<span class="sd">            subset.append(list(current_subset))</span>

<span class="sd">            for split_index in range(start_index, len(nums)):</span>
<span class="sd">                recurse(split_index + 1, current_subset + [nums[split_index]])</span>

<span class="sd">        recurse(0, [])</span>

<span class="sd">        return subset</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;docstring for helper&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">temp</span> <span class="o">+</span> <span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">ans</span><span class="p">)</span>

            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.numDecodings"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.numDecodings">[docs]</a>    <span class="k">def</span> <span class="nf">numDecodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 91. Decode Ways (Medium)</span>

<span class="sd">        A message containing letters from A-Z can be encoded into numbers using the following mapping:</span>

<span class="sd">        To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &quot;11106&quot; can be mapped into:</span>

<span class="sd">        &quot;AAJF&quot; with the grouping (1 1 10 6)</span>
<span class="sd">        &quot;KJF&quot; with the grouping (11 10 6)</span>

<span class="sd">        Note that the grouping (1 11 06) is invalid because &quot;06&quot; cannot be mapped into &#39;F&#39; since &quot;6&quot; is different from &quot;06&quot;.</span>

<span class="sd">        Given a string s containing only digits, return the number of ways to decode it.</span>

<span class="sd">        The test cases are generated so that the answer fits in a 32-bit integer.</span>

<span class="sd">        :param s:  string containing only digits</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  the number of ways to decode it</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># possible value of state</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># initialize the possible value of state, &#39;&#39; and &#39;1&#39; or &#39;0&#39;</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

            <span class="c1"># find the rule and police function</span>
            <span class="c1"># the number of way to decode (dp) depends only on digits (s[i-1:i] or s[i-2: i]). </span>
            <span class="c1"># so seek a rule with two conditions</span>
            <span class="c1"># one digit (0 ~ 9)</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># tow digits (10 ~ 26)</span>
            <span class="k">if</span> <span class="mi">10</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">26</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">getMinimumDays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parcels</span><span class="p">):</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">parcels</span><span class="p">:</span>
            <span class="n">minCapacity</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">parcels</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parcels</span><span class="p">)):</span>
                <span class="n">parcels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parcels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">minCapacity</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parcels</span><span class="p">)):</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">parcels</span><span class="p">:</span>
                    <span class="n">parcels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">cut</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cut</span>

<div class="viewcode-block" id="Solution.longestNiceSubstring"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.longestNiceSubstring">[docs]</a>    <span class="k">def</span> <span class="nf">longestNiceSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 1763. Longest Nice Substring (Easy)</span>

<span class="sd">        A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. </span>
<span class="sd">        For example, &quot;abABB&quot; is nice because &#39;A&#39; and &#39;a&#39; appear, and &#39;B&#39; and &#39;b&#39; appear. However, &quot;abA&quot; is not </span>
<span class="sd">        because &#39;b&#39; appears, but &#39;B&#39; does not.</span>

<span class="sd">        Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. </span>
<span class="sd">        If there are none, return an empty string.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  the longest substring</span>
<span class="sd">        :rtype:   str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">dfs_substring</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span><span class="p">])</span>

            <span class="c1"># DFS</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>

                <span class="c1"># Nice substring (conditions)</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">chars</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">chars</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Search pruning</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">dfs_substring</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="c1"># left-side traversal</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">dfs_substring</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="c1"># right-side traversal</span>
                <span class="k">return</span> <span class="n">s1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="k">else</span> <span class="n">s2</span>

            <span class="c1"># (idea) longest nice substring</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dfs_substring</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span></div>

<div class="viewcode-block" id="Solution.containDuplicate"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.containDuplicate">[docs]</a>    <span class="k">def</span> <span class="nf">containDuplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 217. Contains Duplicate docstring for containDuplicate</span>

<span class="sd">        Given an integer array nums, return true if any value appears at least twice in the array, and return false</span>
<span class="sd">        if every element is distinct.</span>

<span class="sd">        :param List[int]:  an integer array nums</span>
<span class="sd">        :type  List[int]:  List[int]</span>

<span class="sd">        :return:  Whether if any value appears at least twice in the array</span>
<span class="sd">        :rtype:   bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot; Time Limit Exceeded</span>
<span class="sd">        dict = []</span>

<span class="sd">        for num in nums:</span>
<span class="sd">            if num in stack:</span>
<span class="sd">                return True</span>
<span class="sd">            else:</span>
<span class="sd">                stack.append(num)</span>

<span class="sd">        return False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">dict</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Solution.moveZeroes"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.moveZeroes">[docs]</a>    <span class="k">def</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 283. Move Zeroes docstring for fname (Easy)</span>

<span class="sd">        Given an integer array nums, move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements.</span>

<span class="sd">        Note that you must do this in-place without making a copy of the array.</span>

<span class="sd">        :param nums:  integer array nums</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  integer array nums that being move all o&#39;s to the end of it while maintaing the relative order of the non-zero elements</span>
<span class="sd">        :rtype:  List[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">fast</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fast</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># swap</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span>
                <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">fast</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">nums</span></div>

<div class="viewcode-block" id="Solution.isValidSudoku"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isValidSudoku">[docs]</a>    <span class="k">def</span> <span class="nf">isValidSudoku</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 36. Valid Sudoku (Medium)</span>

<span class="sd">        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</span>

<span class="sd">        Each row must contain the digits 1-9 without repetition.</span>
<span class="sd">        Each column must contain the digits 1-9 without repetition.</span>
<span class="sd">        Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</span>
<span class="sd">        Note:</span>

<span class="sd">        A Sudoku board (partially filled) could be valid but is not necessarily solvable.</span>
<span class="sd">        Only the filled cells need to be validated according to the mentioned rules.</span>

<span class="sd">        :param board:  Sudoku board</span>
<span class="sd">        :type  board:  List[List[str]]</span>

<span class="sd">        :return:  Determine if Sudoku board is valid</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">checkbox</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;docstring for checkbox&quot;&quot;&quot;</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">row</span><span class="o">+</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">visited</span><span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">checkhorizontalline</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;docstring for checkhorizontalline&quot;&quot;&quot;</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">checkverticalline</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;docstring for checkverticalline&quot;&quot;&quot;</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">checkverticalline</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">checkhorizontalline</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">checkbox</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Solution.halvesAreAlike"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.halvesAreAlike">[docs]</a>    <span class="k">def</span> <span class="nf">halvesAreAlike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 1704. Determine if String Halves Are Alike docstring for halvesAreAlike (Easy)</span>

<span class="sd">        You are given a string s of even length. Split this string into two halves of equal lengths, </span>
<span class="sd">        and let a be the first half and b be the second half.</span>

<span class="sd">        Two strings are alike if they have the same number of vowels (&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;, &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;). </span>

<span class="sd">        Notice that s contains uppercase and lowercase letters.</span>

<span class="sd">        Return true if a and b are alike. Otherwise, return false.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  Determine if string halves are alike</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">size</span><span class="o">//</span><span class="mi">2</span>
        <span class="c1"># stack</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">midpoint</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">midpoint</span><span class="p">:]</span>

        <span class="k">def</span> <span class="nf">countVowels</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">vowel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s2">&quot;aeiouAEIOU&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">vowel</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">countVowels</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">countVowels</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.maxProfitII"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.maxProfitII">[docs]</a>    <span class="k">def</span> <span class="nf">maxProfitII</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 122. Best Time to Buy and Sell Stock II docstring for maxProfit (Medium)</span>
<span class="sd">        </span>
<span class="sd">        You are given an integer array prices where prices[i] is the price of a given stock on the ith day.</span>

<span class="sd">        On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. </span>
<span class="sd">        However, you can buy it then immediately sell it on the same day.</span>

<span class="sd">        Find and return the maximum profit you can achieve.</span>

<span class="sd">        :param prices:  integer array prices</span>
<span class="sd">        :type  prices:  List[int]</span>

<span class="sd">        :return:  the maximum profit you can achieve</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">price</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">price</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">price</span>
        <span class="k">return</span> <span class="n">total</span></div>

<div class="viewcode-block" id="Solution.maxProfit"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.maxProfit">[docs]</a>    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 121. Best Time to Buy and Sell Stock (Easy)</span>

<span class="sd">        You are given an array prices where prices[i] is the price of a given stock on the ith day.</span>

<span class="sd">        You want to maximize your profit by choosing a single day to buy one stock and </span>
<span class="sd">        choosing a different day in the future to sell that stock.</span>

<span class="sd">        Return the maximum profit you can achieve from this transaction. </span>
<span class="sd">        If you cannot achieve any profit, return 0.</span>

<span class="sd">        :param prices:  integer array prices</span>
<span class="sd">        :type  prices:  List[int]</span>

<span class="sd">        :return:  maximum profit you can achieve from this transaction</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># possible value of state</span>
        <span class="n">dp_hold</span><span class="p">,</span> <span class="n">dp_not_hold</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">stock_price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>

            <span class="c1"># find the rule and police function</span>
            <span class="c1"># either keep in hold, or just buy today with stock price</span>
            <span class="n">dp_hold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp_hold</span><span class="p">,</span> <span class="o">-</span> <span class="n">stock_price</span><span class="p">)</span>

            <span class="c1"># either keep in not holding, or just sell today with stock price</span>
            <span class="n">dp_not_hold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp_not_hold</span><span class="p">,</span> <span class="n">dp_hold</span> <span class="o">+</span> <span class="n">stock_price</span><span class="p">)</span>

        <span class="c1"># max profit must be in not-hold state</span>
        <span class="k">return</span> <span class="n">dp_not_hold</span></div>

<div class="viewcode-block" id="Solution.maxProfitwithfee"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.maxProfitwithfee">[docs]</a>    <span class="k">def</span> <span class="nf">maxProfitwithfee</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</span>

<span class="sd">        You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.</span>

<span class="sd">Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</span>

<span class="sd">Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</span>

<span class="sd">        :param prices:  integer array prices</span>
<span class="sd">        :type  prices:  Lint[int]</span>

<span class="sd">        :param fee:  transaction fee</span>
<span class="sd">        :type  fee:  int</span>

<span class="sd">        :return:  the maximum profit you can achieve</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dp_hold</span><span class="p">,</span> <span class="n">dp_sell</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">stock_price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
            <span class="n">dp_sell</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp_sell</span><span class="p">,</span> <span class="n">dp_hold</span> <span class="o">+</span> <span class="n">stock_price</span><span class="p">)</span>
            <span class="n">dp_hold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp_hold</span><span class="p">,</span> <span class="n">dp_sell</span> <span class="o">-</span> <span class="n">stock_price</span> <span class="o">-</span> <span class="n">fee</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dp_sell</span></div>

<div class="viewcode-block" id="Solution.minDeletionSize"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minDeletionSize">[docs]</a>    <span class="k">def</span> <span class="nf">minDeletionSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 944. Delete Columns to Make Sorted (Easy)</span>

<span class="sd">        You are given an array of n strings strs, all of the same length.</span>

<span class="sd">            The strings can be arranged such that there is one on each line, making a grid. For example, </span>
<span class="sd">            strs = [&quot;abc&quot;, &quot;bce&quot;, &quot;cae&quot;] can be arranged as:</span>

<span class="sd">            abc</span>
<span class="sd">            bce</span>
<span class="sd">            cae</span>

<span class="sd">            You want to delete the columns that are not sorted lexicographically. </span>
<span class="sd">            In the above example (0-indexed), columns 0 (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) and 2 (&#39;c&#39;, &#39;e&#39;, &#39;e&#39;) are </span>
<span class="sd">            sorted while column 1 (&#39;b&#39;, &#39;c&#39;, &#39;a&#39;) is not, so you would delete column 1.</span>

<span class="sd">            Return the number of columns that you will delete.</span>

<span class="sd">        :param strs:  array of n string</span>
<span class="sd">        :type  strs:  List[str]</span>

<span class="sd">        :return:  the number of columns that you will delete</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># stock</span>
        <span class="c1"># row</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="c1"># column</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)):</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">strs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># not sorted lexicographically column</span>
            <span class="k">if</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="o">!=</span> <span class="n">temp</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="Solution.WildcardisMatch"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.WildcardisMatch">[docs]</a>    <span class="k">def</span> <span class="nf">WildcardisMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 44. Wildcard Matching (Hard)</span>

<span class="sd">        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39; where:</span>
<span class="sd">        </span>
<span class="sd">        &#39;?&#39; Matches any single character.</span>
<span class="sd">        &#39;*&#39; Matches any sequence of characters (including the empty sequence).</span>
<span class="sd">        The matching should cover the entire input string (not partial).</span>

<span class="sd">        :param s:  input string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :param p:  pattern</span>
<span class="sd">        :type  p:  str</span>

<span class="sd">        :return:  whether or not input staring and pattern are matched</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # [len(p) + 1 X len(s) + 1] : 2-D dynamic programming</span>
<span class="sd">        # [text][pattern]</span>
<span class="sd">        dp = [[False] * (len(s)+1) for _ in range(len(p)+1)]</span>

<span class="sd">        dp[0][0] = True</span>

<span class="sd">        # Matches any sequence of characters (including the empty sequence).</span>
<span class="sd">        for i in range(1, len(dp)):</span>
<span class="sd">            if p[i-1] == &#39;*&#39;:</span>
<span class="sd">                dp[0][i] = dp[0][i-1]</span>

<span class="sd">        for i in range(1, len(dp)):</span>
<span class="sd">            for j in range(1, len(dp[0])):</span>

<span class="sd">                if(p[i-1] == s[j-1] or p[i-1] == &quot;?&quot;):</span>
<span class="sd">                    dp[i][j] = dp[i-1][j-1]</span>

<span class="sd">                if(p[i-1] == &quot;*&quot;):</span>
<span class="sd">                    dp[i][j] = dp[i-1][j] or dp[i][j-1]</span>

<span class="sd">        return dp[-1][-1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">len_s</span><span class="p">,</span> <span class="n">len_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">len_p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Solution.minimumLines"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minimumLines">[docs]</a>    <span class="k">def</span> <span class="nf">minimumLines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stockPrices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 2280. Minimum Lines to Represent a Line Chart (Medium)</span>

<span class="sd">        You are given a 2D integer array stockPrices where stockPrices[i] = [dayi, pricei] indicates the price of the stock on day dayi is pricei. </span>
<span class="sd">        A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis </span>
<span class="sd">        representing the price and connecting adjacent points. One such example is shown below:</span>

<span class="sd">        Return the minimum number of lines needed to represent the line chart.</span>

<span class="sd">        :param stockPrices:  2D integer array stockPrices</span>
<span class="sd">        :type  stockPrices:  List[List[int]]</span>

<span class="sd">        :return:  the minimum number of lines needed to represent the line chart</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stockPrices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stockPrices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stockPrices</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>

        <span class="n">stockPrices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">stockPrices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">stockPrices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">stockPrices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">lines</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="Solution.nextGreaterElement"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.nextGreaterElement">[docs]</a>    <span class="k">def</span> <span class="nf">nextGreaterElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 496. Next Greater Element I (Easy)</span>

<span class="sd">        The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</span>

<span class="sd">        You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.</span>

<span class="sd">        For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2.</span>
<span class="sd">        If there is no next greater element, then the answer for this query is -1.</span>

<span class="sd">        Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.</span>

<span class="sd">        :param nums1:  integer arrays</span>
<span class="sd">        :type  nums1:  List[int]</span>

<span class="sd">        :param nums2:  integer arrays</span>
<span class="sd">        :type  nums2:  List[int]</span>

<span class="sd">        :return:  an array is the next greater element</span>
<span class="sd">        :rtype:  Line[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># stack</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="n">i_index</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i_index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.nextGreaterElementsII"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.nextGreaterElementsII">[docs]</a>    <span class="k">def</span> <span class="nf">nextGreaterElementsII</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 503. Next Greater Element II (Medium)</span>

<span class="sd">        Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.</span>

<span class="sd">        The next greater number of a number x is the first greater number to its traversing-order next in the array, </span>
<span class="sd">        which means you could search circularly to find its next greater number. If it doesn&#39;t exist, return -1 for this number.</span>

<span class="sd">        :param nums:  circular integer array</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the next greater number for every element in nums</span>
<span class="sd">        :rtype:  List[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="c1"># defaule stack</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">size</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">size</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">res</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Solution.dailyTemperatures"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.dailyTemperatures">[docs]</a>    <span class="k">def</span> <span class="nf">dailyTemperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperatures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 739. Daily Temperatures (Medium)</span>

<span class="sd">        Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after </span>
<span class="sd">        the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.</span>

<span class="sd">        :param temperatures:  an array of integers temperatures</span>
<span class="sd">        :type  temperatures:  List[int]</span>

<span class="sd">        :return: an array is the number of days you have to wait after the ith day to get warmer temperature.</span>
<span class="sd">        :rtype:  List[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Stack (LIFO)</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">temperatures</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">temperature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">temperatures</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">temperature</span> <span class="o">&gt;</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">temperature</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Solution.totalStrength"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.totalStrength">[docs]</a>    <span class="k">def</span> <span class="nf">totalStrength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strength</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 2281. Sum of Total Strength of Wizards (Hard)</span>

<span class="sd">        As the ruler of a kingdom, you have an army of wizards at your command.</span>

<span class="sd">        You are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards</span>
<span class="sd">        (i.e. the wizards&#39; strengths form a subarray of strength), the total strength is defined as the product of the following two values:</span>

<span class="sd">        - The strength of the weakest wizard in the group.</span>
<span class="sd">        - The total of all the individual strengths of the wizards in the group.</span>

<span class="sd">        Return the sum of the total strengths of all contiguous groups of wizards.</span>
<span class="sd">        Since the answer may be very large, return it modulo 109 + 7.</span>

<span class="sd">        A subarray is a contiguous non-empty sequence of elements within an array.</span>

<span class="sd">        :param strength:  integer array strength</span>
<span class="sd">        :type  strength:  Lint[int]</span>

<span class="sd">        :return:  the sum of the total strengths of all contiguous groups of wizards</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_strength</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">length_sub</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">length_sub</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strength</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strength</span><span class="p">)</span> <span class="o">-</span> <span class="n">length_sub</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">total_strength</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strength</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">length_sub</span><span class="p">])</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">strength</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="n">length_sub</span><span class="p">])</span>
            <span class="n">length_sub</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">total_strength</span></div>








<div class="viewcode-block" id="Solution.isSameTree"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isSameTree">[docs]</a>    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 100. Same Tree (Easy)</span>
<span class="sd">        </span>
<span class="sd">        Given the roots of two binary trees p and q, write a function to check if they are the same or not.</span>

<span class="sd">        Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</span>

<span class="sd">        :param p:  binary tree</span>
<span class="sd">        :type  p:  Optional[TreeNode]</span>

<span class="sd">        :param q:  binary tree</span>
<span class="sd">        :type  q:  Optional[TreeNode]</span>

<span class="sd">        :return:  Whether two binary trees are considered the same</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">is_same</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">node1</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">node2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">is_same</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node2</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_same</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node2</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">is_same</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.minSwaps"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minSwaps">[docs]</a>    <span class="k">def</span> <span class="nf">minSwaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 2134. Minimum Swaps to Group All 1&#39;s Together II &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; A swap is defined as taking two distinct positions in an array and swapping the values in them.</span>

<span class="sd">        A circular array is defined as an array where we consider the first element and the last element to be adjacent.</span>

<span class="sd">        Given a binary circular array nums, return the minimum number of swaps required to group all 1&#39;s present in the array together at any location.</span>

<span class="sd">        :param nums:  circular array</span>
<span class="sd">        :type  nums:  Lint[int]</span>

<span class="sd">        :return:  the minimum number of swaps required to group all 1&#39;s present in the array together at any location</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">ones</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">max_window</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ones</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># shift window</span>
            <span class="n">window</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">ones</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">max_window</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_window</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ones</span> <span class="o">-</span> <span class="n">max_window</span></div>

<div class="viewcode-block" id="Solution.merge"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 56. Merge Intervals (Medium) &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input</span>

<span class="sd">        :param param:  array of intervals</span>
<span class="sd">        :type  param:  List[List[int]]</span>

<span class="sd">        :return:  an array of the non-overlapping intervals that cover all the intervals in the input</span>
<span class="sd">        :rtype:  Lint[Lint[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">intervals</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.searchInsert"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.searchInsert">[docs]</a>    <span class="k">def</span> <span class="nf">searchInsert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 35. Search Insert Position &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span>

<span class="sd">        You must write an algorithm with O(log n) runtime complexity.</span>

<span class="sd">        :param nums:  sorted array of distinct integers</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the index where it would be if it were inserted in order</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>

            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">middle</span>

        <span class="k">return</span> <span class="n">start</span></div>

<div class="viewcode-block" id="Solution.findLucky"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.findLucky">[docs]</a>    <span class="k">def</span> <span class="nf">findLucky</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 1394. Find Lucky Integer in an Array &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.</span>

<span class="sd">        Return the largest lucky integer in the array. If there is no lucky integer return -1.</span>

<span class="sd">        :param arr:  an array of integers</span>
<span class="sd">        :type  arr:  Lint[int]</span>

<span class="sd">        :return:  the largest lucky integer</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">lucky</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frequency</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">frequency</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">lucky</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lucky</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lucky</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Solution.isValid"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isValid">[docs]</a>    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 20. Valid Parentheses</span>

<span class="sd">        Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.</span>

<span class="sd">        An input string is valid if:</span>

<span class="sd">        Open brackets must be closed by the same type of brackets.</span>
<span class="sd">        Open brackets must be closed in the correct order.</span>

<span class="sd">        :param s:  string containing just characters</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  determine if the input string is valid</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">char</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">char</span> <span class="o">==</span> <span class="s2">&quot;]&quot;</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">char</span> <span class="o">==</span> <span class="s2">&quot;}&quot;</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;{&quot;</span><span class="p">):</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">continue</span>

            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Solution.mergeTwoLists"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.mergeTwoLists">[docs]</a>    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">list2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 21. Merge Two Sorted Lists &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; You are given the heads of two sorted linked lists list1 and list2.</span>

<span class="sd">        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</span>

<span class="sd">        Return the head of the merged linked list.</span>

<span class="sd">        :param list1:  sorted linked list</span>
<span class="sd">        :type  list1:  Optional[ListNode]</span>

<span class="sd">        :param list2:  sorted linked list</span>
<span class="sd">        :type  list2:  Optional[ListNode]</span>

<span class="sd">        :return:  the head of the merged two lists</span>
<span class="sd">        :rtype:  Optional[ListNode]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">list1</span> <span class="ow">and</span> <span class="n">list2</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">list1</span><span class="p">,</span> <span class="n">list2</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span>

        <span class="k">return</span> <span class="n">list1</span> <span class="ow">or</span> <span class="n">list2</span></div>

<div class="viewcode-block" id="Solution.removeNthFromEnd"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.removeNthFromEnd">[docs]</a>    <span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 19. Remove Nth Node From End of List &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given the head of a linked list, remove the nth node from the end of the list and return its head.</span>

<span class="sd">        :param param:  the head of a linked list</span>
<span class="sd">        :type  param:  Optional[ListNode]</span>

<span class="sd">        :return:  the head of a linked list that removed the nth node from the end of the list</span>
<span class="sd">        :rtype:  Optional[ListNode]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dummyNode</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummyNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>

        <span class="n">slow</span> <span class="o">=</span> <span class="n">dummyNode</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">dummyNode</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span>

        <span class="k">while</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span>

        <span class="n">slow</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>

        <span class="k">return</span> <span class="n">dummyNode</span><span class="o">.</span><span class="n">next</span></div>

<div class="viewcode-block" id="Solution.coinChange"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.coinChange">[docs]</a>    <span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 322. Coin Change</span>

<span class="sd">        You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</span>

<span class="sd">        Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</span>

<span class="sd">        You may assume that you have an infinite number of each kind of coin.</span>

<span class="sd">        :param param:  an integer array coins</span>
<span class="sd">        :type  param:  List[int]</span>

<span class="sd">        :return:  the fewest number of coins that you need to make up that amount</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># minimum number of coins that makes up a</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coin</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Solution.countBits"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.countBits">[docs]</a>    <span class="k">def</span> <span class="nf">countBits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 338. Counting Bits &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1&#39;s in the binary representation of i.</span>

<span class="sd">        :param n:  integer</span>
<span class="sd">        :type  n:  int</span>

<span class="sd">        :return:  an array of length n + 1 such that each i, ans[i] is the number of 1&#39;s in the binary representation of i</span>
<span class="sd">        :rtype:  List[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Stack</span>
        <span class="n">ans</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

            <span class="c1"># multiple number of 1&#39;s in the binary representation of i</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">i</span>

            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">prev</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.getSum"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.getSum">[docs]</a>    <span class="k">def</span> <span class="nf">getSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 371. Sum of Two Integers</span>

<span class="sd">        Given two integers a and b, return the sum of the two integers without using the operators + and -</span>

<span class="sd">        :param a:  integer</span>
<span class="sd">        :type  a:  int</span>

<span class="sd">        :param b:  integer</span>
<span class="sd">        :type  b:  int</span>

<span class="sd">        :return:  the sum of the two integers</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use 32bit mask to limit int size to 32bit to prevent overflow</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xffffffff</span>

        <span class="k">while</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">carry</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">mask</span> <span class="k">else</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Solution.numIslands"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.numIslands">[docs]</a>    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 200. Number of Islands (Medium) &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given an m x n 2D binary grid grid which represents a map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.</span>

<span class="sd">        An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</span>

<span class="sd">        :param param:  m x n 2D binary grid</span>
<span class="sd">        :type  param:  List[List[str]]</span>

<span class="sd">        :return:  the number of islands</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="c1"># parent node</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)])</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-1&#39;</span>

                    <span class="c1"># BFS traversal</span>
                    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span>

                            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">yy</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">xx</span><span class="p">][</span><span class="n">yy</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">))</span>
                                <span class="n">grid</span><span class="p">[</span><span class="n">xx</span><span class="p">][</span><span class="n">yy</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-1&#39;</span>

                    <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.strStr"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.strStr">[docs]</a>    <span class="k">def</span> <span class="nf">strStr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">needle</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 28. Implement strStr() &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Implement strStr().</span>

<span class="sd">        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span>

<span class="sd">        :param haystack:  string haystack</span>
<span class="sd">        :type  haystack:  str</span>

<span class="sd">        :param needle:  string needle</span>
<span class="sd">        :type  needle:  str</span>

<span class="sd">        :return: the index of the first occurrence of needle in haystack</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Solution.myAtoi"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.myAtoi">[docs]</a>    <span class="k">def</span> <span class="nf">myAtoi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 8. String to Integer (atoi) &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++&#39;s atoi function).</span>

<span class="sd">        :param param:  string</span>
<span class="sd">        :type  param:  str</span>

<span class="sd">        :return: 32-bit signed integer</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">str2num</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="k">break</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">num</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">num</span>

        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;+&quot;</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">]:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">str2num</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="n">res</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">str2num</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 33. Search in Rotated Sorted Array &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</span>

<span class="sd">        You must write an algorithm with O(log n) runtime complexity.</span>

<span class="sd">        :param param:  array</span>
<span class="sd">        :type  param:  List[int]</span>

<span class="sd">        :param target:  integer target</span>
<span class="sd">        :type  target:  int</span>

<span class="sd">        :return:  the index of target if it is in nums</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">):</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">if</span><span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">mid</span>

            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]):</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]):</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<div class="viewcode-block" id="Solution.permute"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.permute">[docs]</a>    <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 46. Permutations (Medium) &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;  Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</span>

<span class="sd">        :param nums:  array</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  all the possible permutations</span>
<span class="sd">        :rtype:  List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="n">helper</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">temp</span><span class="o">+</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">ans</span><span class="p">)</span>

        <span class="n">helper</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span></div>


<div class="viewcode-block" id="Solution.combinationSum"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.combinationSum">[docs]</a>    <span class="k">def</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 39. Combination Sum  (Medium)</span>

<span class="sd">        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</span>

<span class="sd">        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</span>

<span class="sd">        It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</span>

<span class="sd">        :param candidates:  distinct integer candidates</span>
<span class="sd">        :type  candidates:  List[int]</span>

<span class="sd">        :return:  a list of all unique combinations of candidates where the chosed numbers sum to target</span>
<span class="sd">        :rtype:  List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">backtracking</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">target</span><span class="o">-</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">temp</span><span class="o">+</span><span class="p">[</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">ans</span><span class="p">)</span>

        <span class="n">backtracking</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.combinationSum2"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.combinationSum2">[docs]</a>    <span class="k">def</span> <span class="nf">combinationSum2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 40. Combination Sum II (Medium)</span>

<span class="sd">        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.</span>

<span class="sd">        Each number in candidates may only be used once in the combination.</span>

<span class="sd">        :param param:  a collection of candidate numbers</span>
<span class="sd">        :type  param:  List[int]</span>

<span class="sd">        :param target:  a target number</span>
<span class="sd">        :type  target:  int</span>

<span class="sd">        :return:  all unique combinations in candidates where the candidates numbers sum to target</span>
<span class="sd">        :rtype:  List[List[int]]</span>

<span class="sd">        :raise e:  Description</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">candidates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Each number in candidates may only be used once in the combination.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="n">backtracking</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">target</span><span class="o">-</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">temp</span> <span class="o">+</span> <span class="p">[</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">res</span><span class="p">)</span>

        <span class="n">backtracking</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Solution.restoreIpAddresses"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.restoreIpAddresses">[docs]</a>    <span class="k">def</span> <span class="nf">restoreIpAddresses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 93. Restore IP Addresses (Medium) &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.</span>

<span class="sd">        For example, &quot;0.1.2.201&quot; and &quot;192.168.1.1&quot; are valid IP addresses, but &quot;0.011.255.245&quot;, &quot;192.168.1.312&quot; and &quot;192.168@1.1&quot; are invalid IP addresses.</span>

<span class="sd">        Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.</span>

<span class="sd">        :param s:  string s containing only digits</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  all possible valid IP addresses</span>
<span class="sd">        :rtype:  List[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">[],</span> <span class="s1">&#39;&#39;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">backtrack</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="o">+</span><span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>

        <span class="n">backtrack</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.letterCombinations"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.letterCombinations">[docs]</a>    <span class="k">def</span> <span class="nf">letterCombinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digits</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 17. Letter Combinations of a Phone Number (Medium) &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</span>

<span class="sd">        A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</span>

<span class="sd">        :param param:  a string containing digits from 2-9 inclusive</span>
<span class="sd">        :type  param:  str</span>

<span class="sd">        :return:  all possible letter combinations that the number could represent</span>
<span class="sd">        :rtype:  List[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">ans</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">[],</span> <span class="s1">&#39;&#39;</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="s1">&#39;def&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="s1">&#39;ghi&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="s1">&#39;jkl&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="s1">&#39;mno&#39;</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">:</span> <span class="s1">&#39;pqrs&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">:</span> <span class="s1">&#39;tuv&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">:</span> <span class="s1">&#39;wxyz&#39;</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">[</span><span class="n">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="n">backtracking</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">digits</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>

        <span class="n">backtracking</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>

<div class="viewcode-block" id="Solution.minOperations"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minOperations">[docs]</a>    <span class="k">def</span> <span class="nf">minOperations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 1827. Minimum Operations to Make the Array Increasing &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.</span>

<span class="sd">        For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].</span>
<span class="sd">        Return the minimum number of operations needed to make nums strictly increasing.</span>

<span class="sd">        An array nums is strictly increasing if nums[i] &lt; nums[i+1] for all 0 &lt;= i &lt; nums.length - 1. An array of length 1 is trivially strictly increasing.</span>

<span class="sd">        :param param:  integer array nums</span>
<span class="sd">        :type  param:  List[int]</span>

<span class="sd">        :return:  the minimum number of operations needed to make nums strictly increasing.</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">output</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">output</span></div>

    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 198. House Robber &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</span>

<span class="sd">        Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</span>

<span class="sd">        :param nums:  [1,2,3,1]</span>
<span class="sd">        :type  nums:  4</span>

<span class="sd">        :return:  the maximum amount of money you can rob tonight without alerting the police</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        n = len(nums)</span>
<span class="sd">        if n &gt; 2:</span>
<span class="sd">            nums[2] += nums[0]</span>

<span class="sd">        for i in range(3, n):</span>
<span class="sd">            nums[i] += max(nums[i-2], nums[i-3])</span>
<span class="sd">            print(i, nums[i])</span>

<span class="sd">        return max(nums[n-1], nums[n-2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prev</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">cur</span><span class="p">),</span> <span class="n">cur</span>

        <span class="k">return</span> <span class="n">cur</span>

<div class="viewcode-block" id="Solution.reverseBits"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.reverseBits">[docs]</a>    <span class="k">def</span> <span class="nf">reverseBits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 190. Reverse Bits &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Reverse bits of a given 32 bits unsigned integer.</span>

<span class="sd">        :param n:  32 bits unsigned integer</span>
<span class="sd">        :type  n:  int</span>

<span class="sd">        :return:  Reverse bits</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Solution.removeDuplicates"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.removeDuplicates">[docs]</a>    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 26. Remove Duplicates from Sorted Array &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.</span>
<span class="sd">        </span>
<span class="sd">        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</span>
<span class="sd">        </span>
<span class="sd">        Return k after placing the final result in the first k slots of nums.</span>

<span class="sd">        :param nums:  integer array nums sorted in non-decreasing order.</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  k after placing the final result in the first k slots of nums</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">duplicates</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># replace the duplicate number</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">duplicates</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="n">duplicates</span></div>

<div class="viewcode-block" id="Solution.rob"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.rob">[docs]</a>    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 198. House Robber &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</span>

<span class="sd">        Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</span>

<span class="sd">        :param param:  integer array representing the amount of money of each house</span>
<span class="sd">        :type  param:  List[int]</span>

<span class="sd">        :return:  the maximize amount of money you can rob tonight without alerting the police</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rob1</span><span class="p">,</span> <span class="n">rob2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">rob1</span><span class="p">,</span> <span class="n">rob2</span><span class="p">)</span>
            <span class="n">rob1</span> <span class="o">=</span> <span class="n">rob2</span>
            <span class="n">rob2</span> <span class="o">=</span> <span class="n">temp</span>

        <span class="k">return</span> <span class="n">rob2</span></div>

<div class="viewcode-block" id="Solution.maxArea"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.maxArea">[docs]</a>    <span class="k">def</span> <span class="nf">maxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 11. Container With Most Water &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</span>

<span class="sd">        Find two lines that together with the x-axis form a container, such that the container contains the most water.</span>

<span class="sd">        Return the maximum amount of water a container can store.</span>

<span class="sd">        :param height:  integer array height of length n</span>
<span class="sd">        :type  height:  List[int]</span>

<span class="sd">        :return:  the maximum amount of water a container can store</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">maxArea</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">end</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>

        <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Binary search</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="n">area</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">end</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;=</span> <span class="n">maxArea</span><span class="p">:</span>
                <span class="n">maxArea</span> <span class="o">=</span> <span class="n">area</span>

        <span class="k">return</span> <span class="n">maxArea</span></div>

<div class="viewcode-block" id="Solution.myPow"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.myPow">[docs]</a>    <span class="k">def</span> <span class="nf">myPow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 50. Pow(x, n)</span>

<span class="sd">        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).</span>

<span class="sd">        :param x:  the number</span>
<span class="sd">        :type  x:  float</span>

<span class="sd">        :param n:  power</span>
<span class="sd">        :type  n:  int</span>

<span class="sd">        :return:  calculates x raised to the power n</span>
<span class="sd">        :rtype:  float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">myPow</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">myPow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">num</span>

        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">myPow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.groupAnagrams"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.groupAnagrams">[docs]</a>    <span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 49. Group Anagrams</span>

<span class="sd">        Given an array of strings strs, group the anagrams together. You can return the answer in any order.</span>

<span class="sd">        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</span>

<span class="sd">        :param strs:  array of strings</span>
<span class="sd">        :type  strs:  List[str]</span>

<span class="sd">        :return:  the answer in any order</span>
<span class="sd">        :rtype:  List[List[str]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hmap</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)):</span>
            <span class="n">ele</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">hmap</span><span class="p">[</span><span class="n">ele</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hmap</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span></div>

<div class="viewcode-block" id="Solution.hasPathSum"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.hasPathSum">[docs]</a>    <span class="k">def</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">targetSum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 112. Path Sum</span>

<span class="sd">        Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</span>

<span class="sd">        A leaf is a node with no children.</span>

<span class="sd">        :param root:  the root of a binary tree </span>
<span class="sd">        :type  root:  Optional[TreeNode]</span>

<span class="sd">        :param targetSum:  target Sum</span>
<span class="sd">        :type  targetSum:  int</span>

<span class="sd">        :return:  if the tree has a root-to-leaf path that adding up all the values along the path equals targetSum</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">targetSum</span> <span class="o">-=</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.minDepth"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.minDepth">[docs]</a>    <span class="k">def</span> <span class="nf">minDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 111. Minimum Depth of Binary Tree &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given a binary tree, find its minimum depth.</span>

<span class="sd">        The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</span>

<span class="sd">        :param root:  Binary Tree</span>
<span class="sd">        :type  root:  Optional[TreeNode]</span>

<span class="sd">        :return:  minimum depth</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minDepth</span><span class="p">,</span> <span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Solution.wordBreak"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.wordBreak">[docs]</a>    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 139. Word Break &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.</span>

<span class="sd">        Note that the same word in the dictionary may be reused multiple times in the segmentation.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :param wordDict:  dictionary of strings</span>
<span class="sd">        :type  wordDict:  List[str]</span>

<span class="sd">        :return:  If s be segmented into a space-separated sequence of one or more dictionary words</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">indx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">indx</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[:</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Solution.uniquePaths"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.uniquePaths">[docs]</a>    <span class="k">def</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 62. Unique Paths &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.</span>

<span class="sd">        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</span>

<span class="sd">        :param m:  integer</span>
<span class="sd">        :type  m:  int</span>

<span class="sd">        :param n:  integer</span>
<span class="sd">        :type  n:  int</span>

<span class="sd">        :return:  the number of possible unique paths that the robot can take to reach the bottom-right corner</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hs</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># hashtable</span>

        <span class="k">def</span> <span class="nf">dp_path</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hs</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hs</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hs</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dp_path</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span> <span class="o">+</span> <span class="n">dp_path</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">hs</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">dp_path</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.findMin"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.findMin">[docs]</a>    <span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 153. Find Minimum in Rotated Sorted Array</span>

<span class="sd">        Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</span>

<span class="sd">        [4,5,6,7,0,1,2] if it was rotated 4 times.</span>
<span class="sd">        [0,1,2,4,5,6,7] if it was rotated 7 times.</span>

<span class="sd">        :param nums:  sorted rotated array of unique elements</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the minimum element of this array</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.isSubsequence"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isSubsequence">[docs]</a>    <span class="k">def</span> <span class="nf">isSubsequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 392. Is Subsequence &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</span>

<span class="sd">        A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not).</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :param t:  string</span>
<span class="sd">        :type  t:  str</span>

<span class="sd">        :return:  if string s is a subsequence of string t</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.topKFrequent"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.topKFrequent">[docs]</a>    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 347. Top K Frequent Elements &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order</span>

<span class="sd">        :param :  integer array</span>
<span class="sd">        :type  : int</span>

<span class="sd">        :return:  the k most frequent elements</span>
<span class="sd">        :rtype:  List[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">myHash</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="n">array</span> <span class="o">=</span> <span class="p">[[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">myHash</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="n">array</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Solution.firstUniqChar"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.firstUniqChar">[docs]</a>    <span class="k">def</span> <span class="nf">firstUniqChar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 387. First Unique Character in a String</span>

<span class="sd">        Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  the first non-repeating character</span>
<span class="sd">        :rtype:  Type</span>

<span class="sd">        :raise e:  Description</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Solution.mergeTrees"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.mergeTrees">[docs]</a>    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">root2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 617. Merge Two Binary Trees &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; You are given two binary trees root1 and root2.</span>

<span class="sd">        Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</span>

<span class="sd">        Return the merged tree.</span>

<span class="sd">        :param root1:  binary tree</span>
<span class="sd">        :type  root1:  Optional[TreeNode]</span>

<span class="sd">        :param root2:  binary tree</span>
<span class="sd">        :type  root2:  Optional[TreeNode]</span>

<span class="sd">        :return:  the merged tree</span>
<span class="sd">        :rtype:  Optional[TreeNode]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root1</span> <span class="ow">and</span> <span class="n">root2</span><span class="p">:</span>
            <span class="n">root1</span><span class="o">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">root2</span><span class="o">.</span><span class="n">val</span>

            <span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">root1</span> <span class="ow">or</span> <span class="n">root2</span></div>

<div class="viewcode-block" id="Solution.isValidBST"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isValidBST">[docs]</a>    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 98. Validate Binary Search Tree &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given the root of a binary tree, determine if it is a valid binary search tree (BST).</span>

<span class="sd">        :param root:  root of binary tree</span>
<span class="sd">        :type  root:  Optional[TreeNode]</span>

<span class="sd">        :return:  determine if it is a valid binary search tree</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">vaild</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">vaild</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vaild</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">vaild</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.buildTree"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.buildTree">[docs]</a>    <span class="k">def</span> <span class="nf">buildTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">inorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 105. Construct Binary Tree from Preorder and Inorder Traversal</span>

<span class="sd">        Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</span>

<span class="sd">        :param preorder:  preorder binary tree</span>
<span class="sd">        :type  preorder:  List[int]</span>

<span class="sd">        :param inorder:  inorder binary tree</span>
<span class="sd">        :type  inorder:  List[int]</span>

<span class="sd">        :return:  Construct binary tree</span>
<span class="sd">        :rtype:  Optional[TreeNode]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">inorder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">preorder</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>

        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">indx</span><span class="p">])</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">[</span><span class="n">indx</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">root</span></div>

<div class="viewcode-block" id="Solution.uniquePathsWithObstacles"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.uniquePathsWithObstacles">[docs]</a>    <span class="k">def</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacleGrid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 63. Unique Paths II &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m-1][n-1]). The robot can only move either down or right at any point in time.</span>

<span class="sd">        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.</span>

<span class="sd">        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.</span>

<span class="sd">        :param obstacleGrid:  mxn integer array grid</span>
<span class="sd">        :type  obstacleGrid:  List[List[int]]</span>

<span class="sd">        :return:  the number of possible unique paths that the robot can take to reach the bottom-right corner</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">dfs_unique</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">dfs_unique</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">dfs_unique</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dfs_unique</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.climbStairs"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.climbStairs">[docs]</a>    <span class="k">def</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 70. Climbing Stairs</span>

<span class="sd">        You are climbing a staircase. It takes n steps to reach the top.</span>

<span class="sd">        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</span>

<span class="sd">        :param n:  take n steps</span>
<span class="sd">        :type  n:  int</span>

<span class="sd">        :return:  how many distinct ways can climb to the top</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="c1"># base case</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="c1"># general cases</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.numUniqueEmails"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.numUniqueEmails">[docs]</a>    <span class="k">def</span> <span class="nf">numUniqueEmails</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emails</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 929. Unique Email Addresses &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Every valid email consists of a local name and a domain name, separated by the &#39;@&#39; sign. Besides lowercase letters, the email may contain one or more &#39;.&#39; or &#39;+&#39;.</span>

<span class="sd">        If you add periods &#39;.&#39; between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain</span>

<span class="sd">        If you add a plus &#39;+&#39; in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.</span>

<span class="sd">        It is possible to use both of these rules at the same time.</span>

<span class="sd">        Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.</span>

<span class="sd">        :param param:  array of string where we send one email to each emails[i]</span>
<span class="sd">        :type  param:  List[str]</span>

<span class="sd">        :return:  the number of different addresses that actually receive mails</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">emails</span><span class="p">:</span>
            <span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">email</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">+=</span> <span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;@&quot;</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">res</span><span class="p">))</span></div>

<div class="viewcode-block" id="Solution.reverseString"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.reverseString">[docs]</a>    <span class="k">def</span> <span class="nf">reverseString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 344. Reverse String &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Write a function that reverses a string. The input string is given as an array of characters s.</span>

<span class="sd">        You must do this by modifying the input array in-place with O(1) extra memory.</span>

<span class="sd">        :param s:  array of characters</span>
<span class="sd">        :type  s:  List[str]</span>

<span class="sd">        :return:  reverses a string</span>
<span class="sd">        :rtype:  None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">)):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 242. Valid Anagram</span>

<span class="sd">        Given two strings s and t, return true if t is an anagram of s, and false otherwise.</span>

<span class="sd">        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :param t:  string</span>
<span class="sd">        :type  t:  str</span>

<span class="sd">        :return:  Description</span>
<span class="sd">        :rtype:  Type</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Solution.isAnagram"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isAnagram">[docs]</a>    <span class="k">def</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 242. Valid Anagram &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given two strings s and t, return true if t is an anagram of s, and false otherwise.</span>

<span class="sd">        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :param t:  string</span>
<span class="sd">        :type  t:  str</span>

<span class="sd">        :return:  if t is an anagram of s</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">Counter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>

<div class="viewcode-block" id="Solution.reverseVowels"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.reverseVowels">[docs]</a>    <span class="k">def</span> <span class="nf">reverseVowels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 345. Reverse Vowels of a String &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given a string s, reverse only all the vowels in the string and return it.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  reverse only all the vowels in the string</span>
<span class="sd">        :rtype:  str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vow</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">]</span>

        <span class="c1"># stack: LIFO</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">vow</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">vow</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="n">char</span>

        <span class="k">return</span> <span class="n">char</span></div>

<div class="viewcode-block" id="Solution.isIsomorphic"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.isIsomorphic">[docs]</a>    <span class="k">def</span> <span class="nf">isIsomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 205. Isomorphic Strings</span>
<span class="sd">        </span>
<span class="sd">        Given two strings s and t, determine if they are isomorphic.</span>

<span class="sd">        Two strings s and t are isomorphic if the characters in s can be replaced to get t.</span>

<span class="sd">        All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</span>

<span class="sd">        :param s:  string</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :param t;  string</span>
<span class="sd">        :type  t;  str</span>

<span class="sd">        :return:  if two string are isomorphic</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># hashtable</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Solution.wordPattern"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.wordPattern">[docs]</a>    <span class="k">def</span> <span class="nf">wordPattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 290. Word Pattern &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given a pattern and a string s, find if s follows the same pattern.</span>

<span class="sd">        Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.</span>

<span class="sd">        :param pattern:  pattern</span>
<span class="sd">        :type  pattern:  str</span>

<span class="sd">        :param s:  non-empty word</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  if there is a bijection between a letter in pattern and a non-empty word in s</span>
<span class="sd">        :rtype:  bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">words</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">words</span><span class="p">)):</span> <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Solution.lengthOfLastWord"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.lengthOfLastWord">[docs]</a>    <span class="k">def</span> <span class="nf">lengthOfLastWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 58. Length of Last Word &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Given a string s consisting of words and spaces, return the length of the last word in the string.</span>

<span class="sd">        A word is a maximal substring consisting of non-space characters only.</span>

<span class="sd">        :param s:  string consisting of words and spaces</span>
<span class="sd">        :type  s:  str</span>

<span class="sd">        :return:  the length if the last word in the string</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Solution.longestCommonPrefix"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.longestCommonPrefix">[docs]</a>    <span class="k">def</span> <span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 14. Longest Common Prefix &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot; Write a function to find the longest common prefix string amongst an array of strings.</span>

<span class="sd">        If there is no common prefix, return an empty string &quot;&quot;.</span>

<span class="sd">        :param strs:  array of strings</span>
<span class="sd">        :type  strs:  List[str]</span>

<span class="sd">        :return:  the longest common prefix string amongst an array of strings</span>
<span class="sd">        :rtype:   str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">res</span>

                <span class="n">res</span> <span class="o">+=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Solution.mergeKLists"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.mergeKLists">[docs]</a>    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; 23. Merge k Sorted Lists</span>

<span class="sd">        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.</span>

<span class="sd">        Merge all the linked-lists into one sorted linked-list and return it.</span>

<span class="sd">        :param lists:  an array of k linked-lists lists</span>
<span class="sd">        :type  lists:  List[Optional[ListNode]]</span>

<span class="sd">        :return:  merge all the linked-lists into one sored linked-list</span>
<span class="sd">        :rtype:  Optional[ListNode]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lists</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">heap</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">heap</span>
            <span class="k">while</span> <span class="n">temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">next</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">vals</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">head</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)):</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">getTopRateFoodOutlets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">page</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">highestcity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">highestrating</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://jsonmock.hackerrank.com/api/food_outlets?city=</span><span class="si">{}</span><span class="s1">&amp;page=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">city</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">text</span>
            <span class="n">json_array</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="n">rating</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="n">cities</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">json_array</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]:</span>
                <span class="n">cities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                <span class="n">rating</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;user_rating&#39;</span><span class="p">][</span><span class="s1">&#39;average_rating&#39;</span><span class="p">]</span>

            <span class="n">sortingrating</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rating</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">elem</span><span class="p">:</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 

            <span class="k">if</span> <span class="n">highestrating</span> <span class="o">&lt;=</span> <span class="n">sortingrating</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">highestrating</span> <span class="o">=</span> <span class="n">sortingrating</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sortingrating</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sortingrating</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">highestcity</span><span class="p">:</span>
                    <span class="n">highestcity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">highestcity</span>

<div class="viewcode-block" id="Solution.kSmallestPairs"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.kSmallestPairs">[docs]</a>    <span class="k">def</span> <span class="nf">kSmallestPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 373. Find K Pairs with Smallest Sums (Medium)</span>

<span class="sd">        You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</span>

<span class="sd">        Define a pair (u, v) which consists of one element from the first array and one element from the second array.</span>

<span class="sd">        Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.</span>

<span class="sd">        :param num1:  integer array sorted in ascending order</span>
<span class="sd">        :type  nums1:  List[int]</span>

<span class="sd">        :param nums2:  integer array sorted in ascending order</span>
<span class="sd">        :type  nums2:  List[int]</span>

<span class="sd">        :return:  the k pair (u1, v1), (u2, v2). ..., (uk, vk)</span>
<span class="sd">        :rtype:  List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">len1</span><span class="p">,</span> <span class="n">len2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="c1"># heap sorted in sums (sums, nums1, nums2, index of array 2)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># k pairs with the smallest sums (BFS)</span>
        <span class="k">while</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">heap</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

            <span class="k">if</span> <span class="n">end</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">len2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums2</span><span class="p">[</span><span class="n">end</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums2</span><span class="p">[</span><span class="n">end</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">end</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Solution.function1"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.function1">[docs]</a>    <span class="k">def</span> <span class="nf">function1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;docstring for function1&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">getDecimalFromBits</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">bit</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">dec</span> <span class="o">=</span> <span class="n">getDecimalFromBits</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">ceil</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dec</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">getBitsFromDecimal</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>

            <span class="n">i</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">)]</span>
            <span class="k">while</span> <span class="n">number</span><span class="p">:</span>
                <span class="n">reminder</span> <span class="o">=</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">reminder</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">number</span> <span class="o">-=</span> <span class="n">sign</span>
                <span class="n">number</span> <span class="o">/=</span> <span class="mi">2</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">):]</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">getBitsFromDecimal</span><span class="p">(</span><span class="n">ceil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">function2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">K</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">K</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">even</span><span class="p">,</span> <span class="n">odd</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">even</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">odd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">even</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">K</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">even</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">even</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">even</span><span class="p">))</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">even</span><span class="p">),</span> <span class="n">odd</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<div class="viewcode-block" id="Solution.search"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.search">[docs]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 704. Binary Search (Easy)</span>

<span class="sd">        Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</span>

<span class="sd">        You must write an algorithm with O(log n) runtime complexity.</span>

<span class="sd">        :param nums:  an array of integers</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :param target:  integer target</span>
<span class="sd">        :type  target:  int</span>

<span class="sd">        :return:  index of target</span>
<span class="sd">        :rtype:  int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mid</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Solution.floodFill"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.floodFill">[docs]</a>    <span class="k">def</span> <span class="nf">floodFill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">sr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 733. Flood Fill</span>

<span class="sd">        An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.</span>

<span class="sd">        You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].</span>

<span class="sd">        To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.</span>

<span class="sd">        Return the modified image after performing the flood fill.</span>

<span class="sd">        :param image:  integer grid image represents the pixel value of the image</span>
<span class="sd">        :type  image:  List[List[int]]</span>

<span class="sd">        :param sr:  source x-index</span>
<span class="sd">        :type  sr:  int</span>

<span class="sd">        :param sc:  source y-index</span>
<span class="sd">        :type  sc:  int</span>

<span class="sd">        :param color:  color of all of the aforementioned pixels color</span>
<span class="sd">        :type  color:  int</span>

<span class="sd">        :return:  the modified image after performing the flood fill</span>
<span class="sd">        :rtype:   List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">oldValue</span><span class="p">,</span> <span class="n">newValue</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">image</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">newValue</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">image</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">oldValue</span><span class="p">:</span>
                <span class="n">image</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">oldValue</span><span class="p">,</span> <span class="n">newValue</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">oldValue</span><span class="p">,</span> <span class="n">newValue</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">oldValue</span><span class="p">,</span> <span class="n">newValue</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">oldValue</span><span class="p">,</span> <span class="n">newValue</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="n">sr</span><span class="p">][</span><span class="n">sc</span><span class="p">],</span> <span class="n">color</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="Solution.hasCycle"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.hasCycle">[docs]</a>    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 141. Linked List Cycle (Easy)</span>

<span class="sd">        Given head, the head of a linked list, determine if the linked list has a cycle in it.</span>

<span class="sd">        There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&#39;s next pointer is connected to. Note that pos is not passed as a parameter.</span>

<span class="sd">        Return true if there is a cycle in the linked list. Otherwise, return false.</span>

<span class="sd">        :param head:  head of a linked list</span>
<span class="sd">        :type  head:  Optional[List[ListNode]]</span>

<span class="sd">        :return:  whether or not there is a cycle in the linked list</span>
<span class="sd">        :rtype:   bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="n">addr</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cur</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">addr</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">next</span>
                <span class="n">pre</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">addr</span></div>

<div class="viewcode-block" id="Solution.lowestCommonAncestor"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.lowestCommonAncestor">[docs]</a>    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 235. Lowest Common Ancestor of a Binary Search Tree (Easy)</span>

<span class="sd">        Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</span>

<span class="sd">        According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</span>

<span class="sd">        :param root:  binary search tree</span>
<span class="sd">        :type  root:  Optional[TreeNode]</span>

<span class="sd">        :param p:  Tree node</span>
<span class="sd">        :type  p:  Optional[TreeNode]</span>


<span class="sd">        :param q:  Tree node</span>
<span class="sd">        :type  q:  Optional[TreeNode]</span>


<span class="sd">        :return:  the lowest common ancestor of two given nodes in the BST</span>
<span class="sd">        :rtype:   Optional[TreeNode]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">while</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">current</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
            <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">current</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">current</span></div>


<div class="viewcode-block" id="Solution.majorityElement"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.majorityElement">[docs]</a>    <span class="k">def</span> <span class="nf">majorityElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; 169. Majority Element (Easy)</span>

<span class="sd">        Given an array nums of size n, return the majority element.</span>

<span class="sd">        The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.</span>

<span class="sd">        :param nums:  array nums</span>
<span class="sd">        :type  nums:  List[int]</span>

<span class="sd">        :return:  the majority element</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">majority_freq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">majority_freq</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span></div>

<div class="viewcode-block" id="Solution.kClosest"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.kClosest">[docs]</a>    <span class="k">def</span> <span class="nf">kClosest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 973. K Closest Points to Origin (Medium)</span>

<span class="sd">        Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).</span>

<span class="sd">        The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).</span>

<span class="sd">        You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</span>

<span class="sd">        :param points:  an array of points represents a point on the X-Y plane</span>
<span class="sd">        :type  points:  List[List[int]]</span>

<span class="sd">        :param k:  k closest points to the origin (0, 0)</span>
<span class="sd">        :type  k:  int</span>

<span class="sd">        :return:  unique closest points to the origin</span>
<span class="sd">        :rtype:   List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  
        <span class="k">return</span> <span class="n">points</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="Solution.threeSum"><a class="viewcode-back" href="../../../api.html#leetcode.impl.solution.Solution.threeSum">[docs]</a>    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; 15. 3Sum (Medium)</span>

<span class="sd">        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</span>

<span class="sd">        Notice that the solution set must not contain duplicate triplets.</span>

<span class="sd">        :param nums: integer array nums</span>
<span class="sd">        :type  nums: List[int]</span>

<span class="sd">        :return:  all the triplets</span>
<span class="sd">        :rtype:   List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># We sort nums first to more easily find duplicate numbers</span>
        <span class="n">triplets</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># We will store all the valid triplets in here</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span> <span class="c1"># Skip duplicates</span>

            <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">curSum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">curSum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">triplets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="c1"># Skip all duplicates on left side</span>
                    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]:</span>
                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Skip all duplicates on right side</span>
                    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">curSum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Our sum is too small, so we try to increase the sum</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># Our sum is too big, so we try to decrease the sum</span>

        <span class="k">return</span> <span class="n">triplets</span></div></div>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Louis Liu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>